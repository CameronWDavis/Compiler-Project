1)	List all productions from the given LITTLE grammar (See grammar.txt in Project Step 2) that display the left-recursion Links to an external site. property. [2 pts]
This is a list of functions in the grammar that represent left recursion. 
expr_prefix       => expr_prefix factor addop |  empty 
expr_list_tail   =>  , expr expr_list_tail | empty 
stmt_list         =>  stmt stmt_list | empty 
id_tail           =>  , id id_tail |  empty
param_decl_tail   =>  ,  param_decl param_decl_tail |  empty
func_declarations =>  func_decl func_declarations |  empty

2)	How does ANTLR deal with left recursion? 2-3 sentences are adequate (hint: "Left-recursive rules" page Links to an external site. in the official ANTLR documentation). [2 pts]

Expressions are categorized into three types binary, suffix, and prefix. Binary expressions have recursive rule invocations at both the beginning and end of an alternative, like expr + expr. Suffix expressions have a recursive invocation at the beginning but not the end, as in expr + term. Prefix expressions have a recursive invocation at the end but not the beginning, such as term + expr.

3)	What is the name of the specific parsing strategy used by ANTLR? Briefly describe it. 2-3 sentences are adequate (hint: see the preface Links to an external site. of the ANTLR book). [2 pt]

The name is LL star and this strategy is used to read, process, and translate structured text based upon grammars. It will then create program that can parse input files that conforms to the grammar and construct a parse tree representing the input. LL star is flexible in that it can allowing ANTLR to handle a wide range of language recognition and pressing tasks. 

4)	Briefly describe the type of parser code that ANTLR generates. Provide an example from your own Step 2 generated parser code or come up with a toy example (hint: see section 2.2 Links to an external site. of the ANTLR book). [2 pt] 

The parser generates a series of static functions matching rules with keywords. What it is doing is analyzing the names of the rules then using the names to build out a parse tree based on the structure provided. Below is a code snippet of our parsers rule names. 
  private static String[] makeRuleNames() {
                return new String[] {
                        "program", "id", "pgm_body", "decl", "string_decl", "str", "var_decl",
                        "var_type", "any_type", "id_list", "id_tail", "param_decl_list", "param_dec$
                        "param_decl_tail", "func_declarations", "func_decl", "func_body", "stmt_lis$
                        "stmt", "base_stmt", "assign_stmt", "assign_expr", "read_stmt", "write_stmt$
                        "return_stmt", "expr", "expr_prefix", "factor", "factor_prefix", "postfix_e$
                        "call_expr", "expr_list", "expr_list_tail", "primary", "addop", "mulop",
                        "if_stmt", "else_part", "cond", "compop", "while_stmt"
                };
        }
 
5)	Generate your own valid and invalid LITTLE source programs. Name them groupX-valid.micro and groupX-invalid.micro, where X is your group number. Upload these two programs with this assignment. The best programs as voted by the students may be added to the official test suite used for grading Step 2. Please make sure both your programs are lexically correct (using your Step 1 scanner). In addition, try to make sure your groupX-valid.micro is also syntactically correct. [2 pts]

Invalid Program 

PROGRAM recursion

BEGIN
        INT x;
        FUNCTION VOID main(x)
        BEGIN
        x:= 50;
        recursionSub(x);
        END
        FUNCTION VOID recursionSub(INT x) BEGIN

        IF (x = 0)
        RETURN
        ELSEIF (x > 0)
        x:= x - 1;
        recursionSub(x);
        END

END



Valid Program 
PROGRAM valid
BEGIN

        INT a,b,d;

        FUNCTION INT main()
        BEGIN

        a:= 4;
        b:= 5;
        d:= a * b;
        WHILE (d != 0)
                WRITE(d);
                d:= d - 1;
        ENDWHILE
        RETURN d;

        END
